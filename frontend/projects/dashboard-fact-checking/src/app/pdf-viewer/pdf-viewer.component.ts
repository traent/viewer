import {
  AfterViewInit,
  Component,
  ElementRef,
  EventEmitter,
  HostListener,
  Input,
  Output,
  QueryList,
  ViewChildren,
  NgZone,
} from '@angular/core';
import { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';
import equal from 'fast-deep-equal';
import {
  getCurrentPage,
  getPages,
  scrollToPage,
  PageRect,
} from '@traent/ngx-components';
import { PDFDocumentProxy, PDFPageProxy, TextContent } from 'pdfjs-dist/types/display/api';
import { BehaviorSubject, Observable, Subject, combineLatest } from 'rxjs';
import { map, switchMap, startWith, debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { required, waitAnimationFrame } from '@traent/ts-utils';

@Component({
  // eslint-disable-next-line @angular-eslint/component-selector
  selector: 'app-pdf-viewer',
  templateUrl: './pdf-viewer.component.html',
  styleUrls: ['./pdf-viewer.component.scss'],
})
@UntilDestroy()
export class PdfViewerComponent implements AfterViewInit {
  // Public APIs
  @Input() data: PDFDocumentProxy | null = null;

  private readonly zoomChange$ = new BehaviorSubject(1);
  @Input() set zoom(value: number) {
    this.zoomChange$.next(value);
  }
  get zoom(): number {
    return this.zoomChange$.value;
  }

  @Input() textRendering = true;

  @Output() readonly contentLoad = new EventEmitter<void>();
  @Output() readonly layoutChange = new EventEmitter<PageRect[]>();

  @Output() readonly containerClick = new EventEmitter<void>();

  @Output() readonly currentPage = new EventEmitter<number>();

  /**
   * DOM elements generated by Angular directives from the PDF.
   * It's an overlay on top of PDF Canvas and all
   */
  @ViewChildren('pageElement') pageElementRefs?: QueryList<ElementRef<HTMLDivElement>>;

  // Internals
  private selectionContainer: HTMLDivElement | null = null;
  private silenceSelection = true;
  private readonly sizeChange$ = new Subject<void>();

  readonly scrollToPage = scrollToPage;

  /**
   * @deprecated use `currentPage` output instead
   */
  private currentPage$?: Observable<number>;

  constructor(private readonly ngZone: NgZone) {}

  ngAfterViewInit(): void {
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    this.data?.getData().then(() => this.contentLoad.next());

    const pageRefs = this.pageElementRefs;
    required(pageRefs);

    // TODO: remove this as soon as possible, it should not be used at all
    this.currentPage$ = pageRefs.changes.pipe(switchMap((pages) => getCurrentPage(pages)));

    pageRefs.changes.pipe(
      switchMap((pages) => getCurrentPage(pages)),
      untilDestroyed(this),
    ).subscribe((current) => this.currentPage.next(current));

    combineLatest([
      pageRefs.changes,
      this.sizeChange$.pipe(startWith([undefined]), debounceTime(50)),
      this.zoomChange$,
    ]).pipe(
      waitAnimationFrame(),
      map(() => pageRefs.map((x) => ({
        // CHECKME: should we use offsetXXX or getBoundingClientRect?
        top: x.nativeElement.offsetTop,
        left: x.nativeElement.offsetLeft,
        width: x.nativeElement.offsetWidth,
        height: x.nativeElement.offsetHeight,
      }))),
      distinctUntilChanged(equal),
      untilDestroyed(this),
    ).subscribe((layout) => this.layoutChange.emit(layout));
  }

  @HostListener('window:resize')
  handleResize(): void {
    this.sizeChange$.next();
  }

  onSelectionStart(element: HTMLDivElement, _event: Event): void {
    this.selectionContainer = element;
    this.silenceSelection = true;
  }

  /**
   * @deprecated use `currentPage` output instead
   */
  getCurrentPage(): Observable<number> | undefined {
    return this.currentPage$;
  }

  getPages = (pdf: PDFDocumentProxy): Promise<Array<PDFPageProxy>> => new Promise(async (resolve, reject) => {
    await this.ngZone.runOutsideAngular(() => getPages(pdf).then(resolve, reject));
  });

  getTextContent = (page: PDFPageProxy): Promise<TextContent> => new Promise(async (resolve, reject) => {
    await this.ngZone.runOutsideAngular(() => page.getTextContent().then(resolve, reject));
  });

  getAnnotations = (page: PDFPageProxy): Promise<any[]> => new Promise(async (resolve, reject) => {
    await this.ngZone.runOutsideAngular(() => page.getAnnotations().then(resolve, reject));
  });

  getPageViewport = (page: PDFPageProxy) => {
    const container = document.getElementById('pdf-viewer-content');

    if (!container) {
      return { width: '100%', height: '100%' };
    }

    const unscaledViewport = page.getViewport({ scale: this.zoom  });
    const scale = container.clientWidth / unscaledViewport.width;
    const viewport = page.getViewport({ scale });
    if (page.pageNumber === 1) {
      // console.log('-------- PDF Viewer calculating page viewport', page.pageNumber);
      // console.log('[pdf-viewer] scale', scale);
      // console.log('[pdf-viewer] opal-container width / height', opal-container.clientWidth, opal-container.clientHeight);
      // console.log('[pdf-viewer] unscaled viewport width / height', unscaledViewport.width, unscaledViewport.height);
      // console.log('[pdf-viewer] scaled viewport width / height', viewport.width, viewport.height);
    }

    return viewport;
  };

}
